[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exploratory Data Analysis of the Golub Gene Expression Dataset",
    "section": "",
    "text": "The advent of high-throughput sequencing technologies and DNA microarray profiling has revolutionized the field of bioinformatics, providing unprecedented insights into genetic variations associated with diseases. One such disease where genomics plays a crucial role in diagnosis is leukemia, a cancer of the blood and bone marrow. Leukemia is categorized into various subtypes, with Acute Myeloid Leukemia (AML) and Acute Lymphoblastic Leukemia (ALL) being two of the most common and clinically significant types. Differentiating between these subtypes is vital for treatment decisions and patient outcomes. Traditional diagnostic methods have relied heavily on clinical parameters and cytological findings. However, with the availability of gene expression data, a more precise and personalized approach can be developed.\nThis project centers around the Golub Gene Expression Dataset, a well-known collection of gene expression data that was initially used in a study by Golub et al. in 1999. The dataset contains gene expression measurements from DNA microarray experiments conducted on 72 patients, each classified as either suffering from AML or ALL. The dataset includes over 7,000 genes, each representing a potential marker for cancer type identification. Our primary goal is to explore this dataset through various data science techniques to understand which genes are most predictive of leukemia subtype and to determine whether these gene expression profiles can be effectively used for classification tasks.\nWe chose this topic because it presents a perfect opportunity to bridge the gap between machine learning techniques and real-world biological data. Understanding the relationship between gene expression and disease classification is an exciting and meaningful application of data science. It also provides an opportunity to apply sophisticated data analysis techniques, such as exploratory data analysis (EDA), dimensionality reduction, clustering, and classification, which are essential skills in modern data science.\nOur research questions focus on understanding how gene expression data can be analyzed and visualized to draw meaningful biological inferences. Specifically, we aim to explore:\n\nGene Identification: Which genes are most significantly associated with the classification of AML and ALL? How can we identify these genes from the dataset?\nDimensionality Reduction: The Golub dataset contains more than 7,000 genes, leading to a high-dimensional feature space. How can we use dimensionality reduction techniques, such as Principal Component Analysis (PCA), to reduce the complexity of the data while preserving as much variance as possible? Can PCA reveal patterns or structures that differentiate between AML and ALL?\nClustering: Is there an inherent structure in the data that can be uncovered through unsupervised learning? How well do clustering techniques like K-Means perform in grouping the samples into distinct clusters corresponding to the two leukemia types? What insights can we draw from the clustering results?\nClassification: Can we develop a robust classification model to predict the leukemia subtype of a patient based on their gene expression profile? How well do techniques like logistic regression perform in identifying the most relevant genes for distinguishing between AML and ALL?\n\nThe project is also designed to address several technical challenges inherent in working with high-dimensional biological data. One such challenge is the inherent imbalance in the dataset—AML and ALL samples are not perfectly balanced, which can affect model performance. Additionally, gene expression data is often noisy and requires careful preprocessing to ensure that the data is ready for analysis. We aim to demonstrate the application of various methods to handle these issues, such as data normalization, feature selection, and cross-validation.\nThe methodology of this project involves several stages, beginning with thorough exploratory data analysis (EDA). EDA will include univariate and multivariate statistical analysis, data visualization through histograms, boxplots, and scatter plots, and the identification of missing or anomalous data points. After understanding the general structure of the dataset, we will apply dimensionality reduction techniques, such as PCA, to reduce the number of features and visualize the data in lower dimensions. This will help us understand how the data clusters and whether we can clearly distinguish between AML and ALL using a reduced set of features.\nNext, we will apply unsupervised learning techniques, particularly K-Means clustering, to check if the data naturally divides into two clusters that correspond to the two types of leukemia. This unsupervised analysis will provide insights into how well-separated the AML and ALL classes are based on gene expression and whether clustering methods can perform well on this dataset.\nFinally, we will apply supervised learning methods such as logistic regression to classify the leukemia subtypes based on the gene expression data. We will also explore feature importance to identify the most significant genes in the classification process. Given the challenge of imbalanced datasets, we will consider various approaches, including data resampling techniques (e.g., random oversampling and undersampling), to improve model performance.\nThroughout the project, we will provide extensive visualizations to help interpret the results and communicate our findings effectively. Gene expression data is complex and multi-dimensional, so clear, concise visualizations are essential to uncover meaningful patterns. We will include various types of plots, such as PCA plots, heatmaps, dendrograms, and confusion matrices, to help visualize the relationships between different genes, the separation of the leukemia subtypes, and the effectiveness of our classification models.\nOur aim is not only to gain biological insights into the classification of leukemia subtypes but also to showcase the power of modern data science techniques in the analysis of genomic data. This project allows us to apply data science principles such as dimensionality reduction, clustering, and classification, while also contributing to a better understanding of how machine learning can be applied to solve problems in the field of bioinformatics.\nIn addition to answering the research questions posed, this project will serve as a valuable exercise in applying a comprehensive range of data science techniques to a real-world biomedical problem. As a team, we are eager to contribute to this exciting intersection of biology and data science and demonstrate how computational methods can enhance our understanding of complex diseases like leukemia.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "2  Data",
    "section": "",
    "text": "2.1 Technical Description\nFor this project, we are using the Golub leukemia dataset, which is a popular dataset used in bioinformatics for classification tasks. This dataset consists of gene expression data from 72 leukemia samples, which are used to classify the samples into three different leukemia types.\nCode\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(cyberpunk)\nlibrary(dplyr)\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nCode\ngolub_data &lt;- read_csv(\"data/golub.csv\")\n\n\nRows: 72 Columns: 7135\n\n\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr    (5): BM.PB, Gender, Source, tissue.mf, cancer\ndbl (7130): Samples, AFFX-BioB-5_at, AFFX-BioB-M_at, AFFX-BioB-3_at, AFFX-Bi...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#technical-description",
    "href": "data.html#technical-description",
    "title": "2  Data",
    "section": "",
    "text": "Source: OpenIntro. The dataset can be accessed here.\nDescription: The dataset contains gene expression data for 72 leukemia samples. The samples are collected from both bone marrow (BM) and peripheral blood (PB), and are labeled as either Acute Lymphoblastic Leukemia (ALL) or Acute Myeloid Leukemia (AML). The dataset also includes various demographic information about the samples.\nVariables:\n\nSamples: A numeric vector indicating the sample number for each observation.\nBM.PB: A factor variable with two levels — BM (bone marrow) and PB (peripheral blood), which identifies the source of the sample.\nGender: A factor variable with levels F (female) and M (male), identifying the gender of the individual from whom the sample was taken.\nSource: A factor variable with levels CALGB, CCG, DFCI, and St-Jude, representing the different hospitals from which the samples originated.\ntissue.mf: A factor variable with combinations of tissue type (BM or PB) and gender (f or m), representing the interaction between source and gender.\nCancer Type: A factor variable with three levels: allB (Acute Lymphoblastic Leukemia B-cell type), allT (Acute Lymphoblastic Leukemia T-cell type), and aml (Acute Myeloblastic Leukemia).\n\nGene Expression Data: In addition to these categorical variables, the dataset contains gene expression measurements for 7,129 gene probes, which represent the expression levels of genes for each sample.\nFormat:\n\nThe dataset is provided as a data frame where rows represent individual samples (72 samples) and columns represent gene expression data (7,129 columns for genes), as well as the categorical variables mentioned above.\nThe data frame has 72 rows and 7,129 columns, with each column corresponding to the gene expression level for a particular gene.\n\nCollection: The data was collected using microarray technology, which allows researchers to measure the expression of thousands of genes simultaneously. The samples are derived from leukemia patients and classified into one of the three categories based on the type of leukemia.\nFrequency of Updates: The dataset is static, meaning it is not updated frequently. The original data was collected many years ago and has become a standard benchmark dataset used for classification tasks in bioinformatics.\nImporting the Data: The dataset is available in CSV format, which can be easily loaded into R or Python. Here’s an example of how to load it in R:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#missing-value-analysis",
    "href": "data.html#missing-value-analysis",
    "title": "2  Data",
    "section": "2.2 Missing Value Analysis",
    "text": "2.2 Missing Value Analysis\nBefore conducting any analysis, it’s important to check for missing values in the dataset. Since this dataset is well-structured, we expect there to be no missing values for the categorical variables. However, we will verify this by performing a quick check for missing values in the gene expression data.\n\n2.2.1 Missing Value Summary\nWe first count the number of columns with missing values in the dataset:\n\n\nCode\n# Checking for missing values in the dataset\nmissing_summary &lt;- colSums(is.na(golub_data))\n\n# Find columns that have missing values\nmissing_columns &lt;- missing_summary[missing_summary &gt; 0]\n\ncat(\"Number of columns with missing values: \", length(missing_columns), \"\\n\")\n\n\nNumber of columns with missing values:  1 \n\n\nCode\nif(length(missing_columns) &gt; 0) {\n  cat(\"\\nColumns with missing values:\\n\")\n  print(missing_columns)\n}\n\n\n\nColumns with missing values:\nGender \n    23 \n\n\n\n\n2.2.2 Heatmap of missing values\n\n\nCode\nlibrary(VIM)\n\n\nWarning: package 'VIM' was built under R version 4.4.2\n\n\nLoading required package: colorspace\n\n\nLoading required package: grid\n\n\nVIM is ready to use.\n\n\nSuggestions and bug-reports can be submitted at: https://github.com/statistikat/VIM/issues\n\n\n\nAttaching package: 'VIM'\n\n\nThe following object is masked from 'package:datasets':\n\n    sleep\n\n\nCode\n# Visualize missing data pattern\nmatrixplot(golub_data, main = \"Missing Data Pattern\")\n\n\n\n\n\n\n\n\n\nThis heatmap does not provide much information due to many columns.\n\n\n2.2.3 Handling Missing Data\nSince the Gender column has only 23 missing values out of a total of 72 observations, this represents a small fraction of the dataset (about 32% of the total observations). There are a few possible approaches to handle this:\n\nRemove rows with missing values (if the missingness is random and not too significant).\nImpute missing values based on the distribution of the Gender column, either by mode imputation (i.e., replacing missing values with the most common value) or by more sophisticated imputation methods.\n\n\n\n2.2.4 Visualization of Missing Data\nTo inspect the missing values specifically in the Gender column of the golub_data dataset, we performed an analysis by first extracting the Gender data and checking for missing values. The number of missing values was then compared to the number of non-missing values, and this comparison was visualized in a bar chart.\nThe bar chart below shows two categories: “Missing” and “Not Missing”. This visualization provides an overview of how much data is missing in the Gender column and how it relates to the total number of observations.\n\n\nCode\n# Extract the Gender column, and missing values in the column\ngender_data &lt;- golub_data$Gender\nmissing_gender &lt;- is.na(gender_data)\n\n# Create a summary of missing values\nmissing_count &lt;- sum(missing_gender)\ntotal_count &lt;- length(gender_data)\n\n# Plot missing values for Gender\nggplot(data.frame(Missing = c(missing_count, total_count - missing_count), \n                  Category = c(\"Missing\", \"Not Missing\")), aes(x = Category, y = Missing)) +\n  geom_bar(stat = \"identity\") +\n  theme_cpunk() +\n  labs(title = \"Missing Values in Gender Column\", \n       x = \"Missing Status\", \n       y = \"Count\") \n\n\n\n\n\n\n\n\n\nAs shown in the plot, about one-third of the entries in the Gender column are missing, and the rest are filled in. This distribution of missing values can impact downstream analysis and may require appropriate handling techniques such as imputation.\nTo understand how the expression levels of the first gene vary across different genders, we extracted the data from the 7th column, which corresponds to the expression levels of the first gene. We then plotted a scatter plot using ggplot2, grouping the samples by gender (Male, Female, or Missing) to observe any trends.\n\n2.2.4.1 Method:\n\nExtracting the Gene Expression Data: We first dynamically extracted the name of the column corresponding to the first gene expression using the colnames() function. This allowed us to reference the specific gene expression data in subsequent steps.\nPlotting the Data: Using ggplot2, we plotted the gene expression levels against gender. The geom_jitter() function was used to avoid overplotting of points by adding small random noise along the x-axis (gender). This technique is particularly useful when there are overlapping data points, which is common in datasets with repeated values.\nPlot Description: The scatter plot helps us visualize the spread of the gene expression levels for the first gene across the different gender groups. This plot provides an initial understanding of whether gender might influence the expression level of this gene, as well as showing any potential outliers or trends.\n\n\n\nCode\nfirst_gene_colname &lt;- colnames(golub_data)[7]\n\n# Plot using the extracted column name\nggplot(golub_data, aes(x = Gender, y = .data[[first_gene_colname]])) +\n  geom_jitter(width = 0.1, height = 0) + # added jitter to avoid overlapping\n  theme_cpunk() +\n  labs(title = paste(\"Scatter Plot of\", first_gene_colname, \"by Gender\"), \n       x = \"Gender\", y = paste(\"Expression of\", first_gene_colname))\n\n\n\n\n\n\n\n\n\n\n\n2.2.4.2 Observations:\nThe scatter plot does not show any significant trend in the distribution of the gender variable. The data points for males, females, and missing values overlap substantially, suggesting that gender does not have a meaningful effect on the expression of the first gene.\n\n\n\n2.2.5 Understanding the distribution of missing data w.r.t to the cancer condition\nThe gender column in our dataset contains missing values. To investigate whether these missing values are associated with the cancer variable, we performed the following steps:\n\nSummary of Missingness: We created an indicator variable to identify rows where the gender column is missing. We calculated the proportion of missing values for each category of cancer.\nVisualization: A bar plot was generated to visualize the proportion of missing values in the gender column across different cancer categories.\nStatistical Test: A Chi-Square test of independence was used to determine whether the missingness in the gender column is significantly associated with the cancer variable.\n\n\n\n\nCode\ngolub_data$gender_missing &lt;- ifelse(is.na(golub_data$Gender), 1, 0)\n\nmissing_summary &lt;- golub_data |&gt;\n  group_by(cancer) |&gt;\n  summarise(\n    missing_count = sum(gender_missing),\n    total_count = n(),\n    missing_proportion = missing_count / total_count\n  )\n\nprint(missing_summary)\n\n\n# A tibble: 3 × 4\n  cancer missing_count total_count missing_proportion\n  &lt;chr&gt;          &lt;dbl&gt;       &lt;int&gt;              &lt;dbl&gt;\n1 allB               6          38              0.158\n2 allT               0           9              0    \n3 aml               17          25              0.68 \n\n\nCode\nggplot(missing_summary, aes(x = cancer, y = missing_proportion)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  theme_cpunk(title.size = 13) +\n  labs(title = \"Proportion of Missing Gender Values by Cancer Category\",\n       x = \"Cancer Category\",\n       y = \"Proportion of Missing Values\")\n\n\n\n\n\n\n\n\n\nCode\ngolub_data$cancer &lt;- as.factor(golub_data$cancer)\ngolub_data$gender_missing &lt;- as.factor(golub_data$gender_missing)\n\nchi_sq_test &lt;- chisq.test(table(golub_data$cancer, golub_data$gender_missing))\n\n\nWarning in chisq.test(table(golub_data$cancer, golub_data$gender_missing)):\nChi-squared approximation may be incorrect\n\n\nCode\nprint(chi_sq_test)\n\n\n\n    Pearson's Chi-squared test\n\ndata:  table(golub_data$cancer, golub_data$gender_missing)\nX-squared = 23.736, df = 2, p-value = 7.012e-06\n\n\n\n2.2.5.1 Results\nThe proportions of missing values varied across different cancer categories. The Chi-Square test yielded a p-value of 7.012e-06, indicating a statistically significant association between the missingness in the gender column and the cancer variable. This suggests that the pattern of missing data in gender is not random but influenced by the type of cancer the patient has.\nWe update the data so that the missing values are treated as a third level.\n\n\nCode\n# Replace missing values in the gender column with \"Unknown\"\ngolub_data$Gender &lt;- ifelse(is.na(golub_data$Gender), \"Unknown\", golub_data$Gender)\n\n# Convert the gender column to a factor to ensure consistency\ngolub_data$Gender &lt;- as.factor(golub_data$Gender)\n\n# Verify the updated column\ntable(golub_data$Gender)\n\n\n\n      F       M Unknown \n     23      26      23 \n\n\nCode\nwrite.csv(golub_data, file = \"data/golub2.csv\", row.names = FALSE)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "3  Analysis",
    "section": "",
    "text": "3.1 Selection of the 50 Most Important Genes Based on Correlation with Cancer Variables\nIn this section, we will begin by selecting the 50 most important genes based on their correlation with the cancer variable, which indicates the condition the patient is suffering from. This selection is made for the purpose of better understanding the dataset, as we have a large number of genes (~7000 genes), and we want to focus on the most relevant ones at this stage.\nWe will calculate the correlation between each gene’s expression values and the cancer condition, then select the top 50 genes with the highest correlations. This will allow us to narrow down the dataset for further exploration while ensuring we capture the most significant gene-cancer relationships.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analysis</span>"
    ]
  },
  {
    "objectID": "results.html#selection-of-the-50-most-important-genes-based-on-correlation-with-cancer-variables",
    "href": "results.html#selection-of-the-50-most-important-genes-based-on-correlation-with-cancer-variables",
    "title": "3  Analysis",
    "section": "",
    "text": "3.1.1 Data Preparation\nFirst, let’s load the necessary libraries and inspect the structure of the dataset.\n\n\nCode\ngolub_data &lt;- read.csv(\"data/golub2.csv\")\nlibrary(dplyr)\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nCode\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(cyberpunk)\n\n\n\n\n3.1.2 Extracting Gene Expression and Cancer Condition\nThe cancer condition is in the sixth column of the dataset, and the gene expression data starts from the 7th column onward. We will separate the cancer variable from the gene expression data for further analysis.\n\n\nCode\ncancer_condition &lt;- golub_data[, 6]\n\ngene_expression &lt;- golub_data[, 7:ncol(golub_data)]\n\n\n\n\n3.1.3 Correlation with Cancer Condition\nNow, we will calculate the correlation between each gene’s expression and the cancer condition. To do this, we will assume that the cancer variable is numeric (if it’s categorical, we may need to encode it before correlation). We will compute the Pearson correlation coefficient between each gene and the cancer variable. Below are the correlations for the top 50 genes.\n\n\nCode\ncancer_condition_numeric &lt;- as.numeric(as.factor(cancer_condition))\n\ncorrelations &lt;- apply(gene_expression, 2, function(x) cor(x, cancer_condition_numeric, method = \"pearson\"))\n\ncorrelation_df &lt;- data.frame(Gene = colnames(gene_expression), Correlation = correlations)\n\ntop_50_genes &lt;- correlation_df |&gt;\n  arrange(desc(abs(Correlation))) |&gt;\n  head(50)\n\ntop_50_genes\n\n\n                             Gene Correlation\nX95735_at               X95735_at   0.7582368\nM84371_rna1_s_at M84371_rna1_s_at  -0.7300247\nU05259_rna1_at     U05259_rna1_at  -0.7281368\nM89957_at               M89957_at  -0.7227623\nY08612_at               Y08612_at  -0.7210901\nM31523_at               M31523_at  -0.7173077\nM55150_at               M55150_at   0.6990670\nM63138_at               M63138_at   0.6876458\nM23197_at               M23197_at   0.6858295\nM27891_at               M27891_at   0.6821055\nX17042_at               X17042_at   0.6777638\nU46499_at               U46499_at   0.6736084\nM22960_at               M22960_at   0.6735003\nM16038_at               M16038_at   0.6732179\nM84526_at               M84526_at   0.6731514\nL09209_s_at           L09209_s_at   0.6722279\nX61587_at               X61587_at   0.6703648\nJ03473_at               J03473_at  -0.6692006\nM11722_at               M11722_at  -0.6620371\nD88270_at               D88270_at  -0.6610697\nM62762_at               M62762_at   0.6596790\nM32304_s_at           M32304_s_at   0.6556414\nM33680_at               M33680_at  -0.6532509\nS46622_at               S46622_at  -0.6502294\nM31211_s_at           M31211_s_at  -0.6464431\nM81695_s_at           M81695_s_at   0.6445153\nU59878_at               U59878_at   0.6410530\nU50136_rna1_at     U50136_rna1_at   0.6361436\nM11147_at               M11147_at   0.6355428\nX63469_at               X63469_at  -0.6306590\nX58529_at               X58529_at  -0.6288124\nX64072_s_at           X64072_s_at   0.6273746\nZ15115_at               Z15115_at  -0.6271395\nU22376_cds2_s_at U22376_cds2_s_at  -0.6260432\nX66401_cds1_at     X66401_cds1_at  -0.6222472\nM98045_at               M98045_at  -0.6195427\nX14008_rna1_f_at X14008_rna1_f_at   0.6189717\nM65214_s_at           M65214_s_at  -0.6177227\nJ03801_f_at           J03801_f_at   0.6163078\nM92287_at               M92287_at  -0.6138928\nM28170_at               M28170_at  -0.6138172\nM19045_f_at           M19045_f_at   0.6137965\nL06797_s_at           L06797_s_at  -0.6114739\nU82759_at               U82759_at   0.6098424\nX16546_at               X16546_at   0.6087719\nY07604_at               Y07604_at   0.6078124\nZ49194_at               Z49194_at  -0.6072482\nX15414_at               X15414_at  -0.6059287\nM63838_s_at           M63838_s_at  -0.6039670\nU79285_at               U79285_at  -0.6008714\n\n\nVisualizing the correlations\n\n\nCode\nggplot(correlation_df, aes(x = Correlation)) +\n  geom_histogram(bins = 30) +\n  labs(title = \"Distribution of Correlations\",\n       x = \"Correlation Coefficient\",\n       y = \"Frequency\") +\n  theme_cpunk(title.size = 13)\n\n\n\n\n\n\n\n\n\n\n\n3.1.4 Visualizing the Top 50 Genes\nTo better understand the relationships between the top 50 genes and the cancer condition, we can create a bar plot to visualize the correlations. This plot will help us quickly identify the genes with the strongest relationships with the cancer condition.\n\n\nCode\nggplot(top_50_genes, aes(x = reorder(Gene, Correlation), y = Correlation)) +\n  geom_bar(stat = \"identity\", fill = \"lightblue\") +\n  coord_flip() +\n  labs(title = \"Top 50 Genes Correlated with Cancer Condition\",\n       x = \"Gene\",\n       y = \"Correlation with Cancer Condition\") +\n  theme_cpunk(title.size = 13) +\n  theme(axis.text.y = element_text(size = 7))\n\n\n\n\n\n\n\n\n\n\n\nCode\ntop_50_gene_data &lt;- gene_expression[, top_50_genes$Gene]\ntop_50_gene_names &lt;- top_50_genes$Gene\ntop_50_genes_subset &lt;- golub_data[, c(1:6, which(colnames(golub_data) %in% top_50_gene_names))]\nwrite.csv(top_50_genes_subset, file = \"data/top_50.csv\", row.names = FALSE)\n\n\n\n\n3.1.5 Correlation Matrix for Top 50 Genes\nNext, we compute and visualize a correlation matrix among the top 50 genes to identify any strong relationships between them.\n\n\nCode\nlibrary(reshape2)\n\n\n\nAttaching package: 'reshape2'\n\n\nThe following object is masked from 'package:tidyr':\n\n    smiths\n\n\nCode\n# Create the correlation matrix\ngene_corr_matrix &lt;- cor(top_50_gene_data)\n\n# Reshape the correlation matrix into long format for ggplot\ngene_corr_matrix_melted &lt;- melt(gene_corr_matrix)\n\n# Plot the heatmap using ggplot2 with cyberpunk theme\nggplot(gene_corr_matrix_melted, aes(Var1, Var2, fill = value)) +\n  geom_tile() +  # Creates the heatmap tiles\n  scale_fill_gradientn(colors = c(\"#000000\", \"#E200F7\", \"#00FFFF\", \"#FFFFFF\")) +  # Set cyberpunk colors\n  theme_cpunk() +  # Use the cyberpunk theme\n  labs(title = \"Correlation Matrix of Top 50 Genes\", x = \"Genes\", y = \"Genes\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n\n\n\n\n\n\n\n\nPairwise scatterplots for the top 5 genes\n\n\nCode\nlibrary(GGally)\n\n\nRegistered S3 method overwritten by 'GGally':\n  method from   \n  +.gg   ggplot2\n\n\nCode\nggpairs(top_50_gene_data[, 1:5], \n        title = \"Scatterplot Matrix for Top 5 Genes\") +\n  theme_cpunk(title.size = 13) +\n  theme(strip.text = element_text(size = 7))\n\n\n\n\n\n\n\n\n\nFrom this scatterplot matrix, you can conclude that several pairs of genes have moderate to strong correlations, such as “X95735_at” and “X08612_at”. The density distributions indicate that the expression levels of these genes vary significantly across samples. The scatterplot matrix helps in identifying potentially related genes that might be involved in similar biological processes or conditions.\n\n\n3.1.6 Gene Expression Boxplots by Cancer Condition\nFinally, we examine how the expression levels of selected highly correlated genes vary across cancer conditions.\n\n\nCode\nselected_genes &lt;- head(top_50_genes$Gene, 3)\n\ncancer_condition_factor &lt;- as.factor(cancer_condition)\n\ngene_boxplots &lt;- lapply(selected_genes, function(gene) {\n  ggplot(data = data.frame(Expression = gene_expression[[gene]], \n                           Cancer = cancer_condition_factor), \n         aes(x = Cancer, y = Expression, fill = Cancer)) +\n    geom_boxplot() +\n    theme_cpunk(title.size = 13) +\n    labs(title = paste(\"Gene Expression of\", gene, \"by Cancer Condition\"),\n         x = \"Cancer Condition\",\n         y = \"Expression Level\") +\n    theme(legend.position = \"none\")\n})\n\nprint(gene_boxplots[[1]])\n\n\n\n\n\n\n\n\n\nCode\nprint(gene_boxplots[[2]])\n\n\n\n\n\n\n\n\n\nCode\nprint(gene_boxplots[[3]])",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analysis</span>"
    ]
  },
  {
    "objectID": "results.html#clustering-to-visualise-the-variation-in-the-dataset",
    "href": "results.html#clustering-to-visualise-the-variation-in-the-dataset",
    "title": "3  Analysis",
    "section": "3.2 Clustering to visualise the variation in the dataset",
    "text": "3.2 Clustering to visualise the variation in the dataset\nWe apply DBSCAN and Heirarchical Clustering. The idea is to treat gene expression levels as features for clustering, and then explore how samples (patients) group together based on their expression profiles. ### DBSCAN\n\n\nCode\ngolub &lt;- read.csv(\"data/golub2.csv\")\n\n# Encode the cancer column\ngolub$cancer &lt;- as.factor(golub$cancer)\ngolub$cancer_condition_numeric &lt;- as.numeric(golub$cancer)\n\n# Select only numeric columns, including the encoded cancer_condition_numeric\nnumeric_data &lt;- golub[, sapply(golub, is.numeric)]\n\n# Perform DBSCAN clustering\nlibrary(dbscan)\n\n\nWarning: package 'dbscan' was built under R version 4.4.2\n\n\n\nAttaching package: 'dbscan'\n\n\nThe following object is masked from 'package:stats':\n\n    as.dendrogram\n\n\nCode\n# Apply DBSCAN clustering to the numeric data, excluding the original categorical variables\ndbscan_result &lt;- dbscan(numeric_data, eps = 0.01, minPts = 2)\n\n# Add the cluster labels to the data frame\ngolub$cluster &lt;- as.factor(dbscan_result$cluster)\n\n\n\n3.2.0.1 Visualize the clustering (using PCA for dimensionality reduction)\n\n\nCode\npca_result &lt;- prcomp(numeric_data, scale. = TRUE)\n\n# Scatter plot of the first two principal components colored by cluster\ngolub$PC1 &lt;- pca_result$x[, 1]\ngolub$PC2 &lt;- pca_result$x[, 2]\n\nggplot(golub, aes(x = PC1, y = PC2, color = cluster)) +\n  geom_point(size = 3, shape = 16) +\n  labs(title = \"DBSCAN Clustering (PCA view)\", \n       x = \"Principal Component 1\", \n       y = \"Principal Component 2\") +\n  theme_cpunk()\n\n\n\n\n\n\n\n\n\n\n\nCode\nexplained_variance &lt;- data.frame(PC = 1:length(pca_result$sdev), \n                                 Variance = pca_result$sdev^2 / sum(pca_result$sdev^2))\n\nggplot(explained_variance, aes(x = PC, y = Variance)) +\n  geom_bar(stat = \"identity\", fill = \"palegreen\") +\n  labs(title = \"Scree Plot\",\n       x = \"Principal Component\",\n       y = \"Proportion of Variance Explained\") +\n  theme_cpunk()\n\n\n\n\n\n\n\n\n\nDBSCAN is not able to identify different clusters. we will now apply a different clustering to technique to see if the samples can be easily separated.\n\n\n3.2.1 Heirarchical Clustering\n\n\nCode\ngolub &lt;- read.csv(\"data/golub2.csv\")\n\n# Encode the cancer column\ngolub$cancer &lt;- as.factor(golub$cancer)\ngolub$cancer_condition_numeric &lt;- as.numeric(golub$cancer)\n\n# Select only numeric columns, including the encoded cancer_condition_numeric\nnumeric_data &lt;- golub[, sapply(golub, is.numeric)]\n\n# Perform Hierarchical Clustering\n# Scale the data before performing hierarchical clustering\nscaled_data &lt;- scale(numeric_data)\n\n# Calculate the distance matrix (Euclidean distance)\ndist_matrix &lt;- dist(scaled_data, method = \"euclidean\")\n\n# Perform Hierarchical Clustering using the Ward.D2 method (minimizes variance)\nhc_result &lt;- hclust(dist_matrix, method = \"ward.D2\")\n\n# Cut the dendrogram into a specified number of clusters (for example, 3 clusters)\ngolub$cluster &lt;- as.factor(cutree(hc_result, k = 3))\n\n\n\n3.2.1.1 Visualize the clustering (using PCA for dimensionality reduction)\n\n\nCode\npca_result &lt;- prcomp(scaled_data, scale. = TRUE)\n\n# Scatter plot of the first two principal components colored by cluster\ngolub$PC1 &lt;- pca_result$x[, 1]\ngolub$PC2 &lt;- pca_result$x[, 2]\n\nggplot(golub, aes(x = PC1, y = PC2, color = cluster)) +\n  geom_point(aes(shape = cancer)) +\n  labs(title = \"Hierarchical Clustering (PCA view)\", \n       x = \"Principal Component 1\", \n       y = \"Principal Component 2\") +\n  theme_cpunk() +\n  scale_shape_manual(values = c(16, 17, 18))\n\n\n\n\n\n\n\n\n\nCode\n# Display the cluster sizes\ntable(golub$cluster)\n\n\n\n 1  2  3 \n38 25  9 \n\n\n\n\nCode\nexplained_variance &lt;- data.frame(PC = 1:length(pca_result$sdev), \n                                 Variance = pca_result$sdev^2 / sum(pca_result$sdev^2))\n\nggplot(explained_variance, aes(x = PC, y = Variance)) +\n  geom_bar(stat = \"identity\", fill = \"palegreen\") +\n  labs(title = \"Scree Plot\",\n       x = \"Principal Component\",\n       y = \"Proportion of Variance Explained\") +\n  theme_cpunk()\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Clustering Challenges in Gene Expression Data\nIn this analysis, we used two methods to group gene expression data from cancer patients based on their genetic features. The goal was to see if we could identify patterns that could help us better understand the different types of cancer. The methods we tried were DBSCAN (Density-Based Clustering) and Hierarchical Clustering. Despite experimenting with different settings, neither method gave us useful results. Below is a summary of what we tried and the challenges we encountered:\n\n3.2.2.1 DBSCAN (Density-Based Clustering)\nDBSCAN is a technique that groups data points that are close to each other in dense areas, while treating points in sparse areas as “noise” or outliers. We tested different settings to see if we could find the best way to cluster the data.\n\n3.2.2.1.1 Challenges:\n\nSensitivity to Parameters: The method depends on two main settings: the distance between points (called eps) and the minimum number of points required to form a cluster (called minPts). When we set the distance too small, most of the points were treated as outliers and were not clustered at all. When we increased the distance, the method still couldn’t find meaningful groups.\nNo Clear Patterns: Even after adjusting the settings, the algorithm did not group the data in a way that made sense, and the results didn’t align well with the known cancer types.\n\n\n\n\n3.2.2.2 Hierarchical Clustering\nHierarchical clustering works by grouping data points into clusters that are increasingly merged together. We used this method to see if it could form meaningful groups based on the gene data. The method also involves cutting the tree of clusters at a specific point to decide how many groups we want.\n\n\nCode\nlibrary(cluster)\n\n# Compute silhouette\nsil &lt;- silhouette(cutree(hc_result, k = 3), dist_matrix)\npar(bg = \"grey50\", col.axis = \"white\", col.lab = \"white\", col.main = \"white\")\n# Plot silhouette with cyberpunk styling\nplot(\n  sil,\n  main = \"Silhouette Plot for Hierarchical Clustering\",\n  col = c(\"#E200F7\", \"#00FFFF\", \"#FF8C00\"), # Cyberpunk colors\n  border = \"white\",                         # Border color\n  do.col.sort = TRUE                        # Ensures colors vary by cluster\n)\n\n\n\n\n\n\n\n\n\n\nCluster Quality: Cluster 2 is problematic, with an extremely low average silhouette width of 0.007, indicating that most of the data points in this cluster are poorly assigned.\nOverall Clustering: The low average silhouette width of 0.13 suggests that the clustering does not provide a very clear separation between clusters. Further tuning of the clustering process (e.g., adjusting the number of clusters, clustering method, or parameters) could potentially improve the clustering quality.\n\n\n3.2.2.2.1 Challenges:\n\nIneffective Grouping: Even after specifying the number of clusters (e.g., 2 or 3), the resulting groups didn’t clearly separate the data. The clusters that were formed were not distinct, and they didn’t align with the actual cancer types.\nSensitivity to Settings: This method also depends on a setting called a “threshold” that decides where to cut the tree. Changing this threshold led to different results, but none of the clusters formed were meaningful.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Analysis</span>"
    ]
  }
]